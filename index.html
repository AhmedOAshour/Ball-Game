<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ThreeJs Sample</title>
    <div class="wrapper">
     <p>Move: W-A-S-D</p>
     <button type="button" id="refresh" onclick="document.location.reload();">Play Again</button>
     <button type="button" id="win" onclick="document.location.reload();">You Win! Play Again</button>
   </div>
   <style>
     body{
       margin: 0px;
       overflow: hidden;
     }
     p{
       position: absolute;
       top: 0%;
       left: 80%;
       z-index: 100;
       display: block;
       color: white;
     }
     #refresh, #win {
         position: absolute;
         top: 50%;
         left: 50%;
         width: 150px;
         height: 150px;
         background-color: darkgreen;
         border-color: darkgreen;
         z-index: 100;
         display: none;
         font-size: 25px;
       }
   </style>
  </head>
  <body>
<script src="lib/three.js"></script>
<script src="lib/OrbitControls.js"></script>
<script src="lib/GLTFLoader.js"></script>
<script src="lib/cannon.js"></script>

<script>
(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()
  var timeStep=1/60;
  var scene = new THREE.Scene();
  //(field of view in degrees, , near clipping plane, far clipping plane)
  var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight)
  document.body.appendChild(renderer.domElement);
  var goal;
   var player;
   const acc=0.1
   const turnrate=0.01;
   const maxSpeed=2;
   const friction = 0.008;
   var speed = 0;
   var speedlr=0;
   //65 left 68 right 87 up 83 down
   var array = {65: false, 68: false, 87: false, 83: false};    //event listener for resizing app to window size
   window.addEventListener('resize', function()
   {
     var width = window.innerWidth;
     var height = window.innerHeight;
     renderer.setSize(width, height);
     camera.aspect = width / height;
     camera.updateProjectionMatrix();
   });

  //event listener for resizing app to window size
  window.addEventListener('resize', function()
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width, height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  });

  //Orbit Control
  controls = new THREE.OrbitControls(camera,renderer.domElement);
  camera.lookAt(0,0,0);
    controls.maxDistance = 50;
    controls.minDistance = 50;
    controls.maxPolarAngle = Math.PI/3;
    controls.minPolarAngle = Math.PI/3;
    controls.rotateSpeed = 1;
    controls.enabled = false;
    camera.position.y = 50;
    camera.position.x = -40
  {
     loader = new THREE.CubeTextureLoader();
     texture = loader.load([
      'models/skybox/front.png',
      'models/skybox/back.png',
      'models/skybox/up.png',
      'models/skybox/down.png',
      'models/skybox/left.png',
      'models/skybox/right.png',

    ]);
    scene.background = texture;
    }
    loader=new THREE.GLTFLoader();
loader.load(
        // resource URL
        // loader = new THREE.GLTFLoader();
        'models/goal/scene.gltf',
        // called when the resource is loaded
      function ( gltf ) {
          goal = gltf.scene;
          goal.scale.set(0.5,0.5,0.5);
          goal.position.set(0, 0, 750);
          scene.add( goal );
      },
        // called while loading is progressing
        function ( xhr ) {
            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        },
        // called when loading has errors
        function ( error ) {
            console.log( 'An error happened' );
        });
  {
     loader = new THREE.CubeTextureLoader();
     texture = loader.load([
      'models/skybox/front.png',
      'models/skybox/back.png',
      'models/skybox/up.png',
      'models/skybox/down.png',
      'models/skybox/left.png',
      'models/skybox/right.png',

    ]);
    scene.background = texture;
    }


  // cubegeometry = new THREE.BoxGeometry( 100, 10, 100 );
  // cubematerial = new THREE.MeshBasicMaterial( {color: 0x0000ff,wireframe :true} );
  // cube = new THREE.Mesh( cubegeometry, cubematerial );
  // // cube.translateY(10);
  // scene.add( cube );
    cubeGeometry = new THREE.CubeGeometry(1200, 10, 300);
    cubeMaterial = new THREE.MeshBasicMaterial( {color:'rgb(0,0,250)'} );
    cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
    scene.add(cube);

    cube1Geometry = new THREE.CubeGeometry(1200, 10, 300);
    cube1Material = new THREE.MeshBasicMaterial( {color:'rgb(100,10,20)'} );
    cube1 = new THREE.Mesh( cube1Geometry, cube1Material );
    scene.add(cube1);

    cube2Geometry = new THREE.CubeGeometry(300, 10, 450);
    cube2Material = new THREE.MeshBasicMaterial( {color:'rgb(100,200,210)'} );
    cube2 = new THREE.Mesh( cube2Geometry, cube2Material );
    scene.add(cube2);

   spheregeometry = new THREE.SphereGeometry( 5, 32, 32 );
   spherematerial = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
   sphere = new THREE.Mesh( spheregeometry, spherematerial );
   // sphere.position.y=20;
   // sphere.translateY(100);

   scene.add( sphere );

   function initCannon() {

          world = new CANNON.World();
          world.gravity.set(0,-25,0);

          world.broadphase = new CANNON.NaiveBroadphase();
          // world.solver.iterations = 10;

          shape = new CANNON.Sphere(5);
          mass = 1;
          sphereBody = new CANNON.Body({
            mass: 1
          });
          sphereBody.addShape(shape);
          sphereBody.position.y=10;
          sphereBody.linearDamping = 0.5;
          world.addBody(sphereBody);
          player=sphere;

          groundShape = new CANNON.Box(new CANNON.Vec3(600,5,150));
          groundMaterial = new CANNON.Material();
          Ccube = new CANNON.Body({
            mass:0,
            material:groundMaterial
          });

          // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
          Ccube.addShape(groundShape);
          Ccube.position.x+=450;
          world.add(Ccube);

          groundShape1 = new CANNON.Box(new CANNON.Vec3(600,5,150));
          ground1Material = new CANNON.Material();
          Ccube1 = new CANNON.Body({
            mass:0,
            material:ground1Material
          });

          // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
          Ccube1.addShape(groundShape1);
          Ccube1.position.x+=450;
          world.add(Ccube1);
          Ccube1.position.z+=750;

          groundShape2 = new CANNON.Box(new CANNON.Vec3(150,5,225));
          ground2Material = new CANNON.Material();
          Ccube2 = new CANNON.Body({
            mass:0,
            material:ground2Material
          });
          Ccube2.addShape(groundShape2);
          Ccube2.position.x+=900;
          Ccube2.position.z+=375;
          world.add(Ccube2);


      }

  //draw scene
  function updatePhysics() {

          // Step the physics world
          world.step(timeStep);

          // Copy coordinates from Cannon.js to Three.js
          sphereBody.position.x=sphere.position.x;
          sphereBody.position.z=sphere.position.z;
          sphere.position.y=sphereBody.position.y;
          sphereBody.quaternion.copy(sphere.quaternion);
          cube.position.copy(Ccube.position);
          cube.quaternion.copy(Ccube.quaternion);
          cube1.position.copy(Ccube1.position);
          cube1.quaternion.copy(Ccube1.quaternion);
          cube2.position.copy(Ccube2.position);
          cube2.quaternion.copy(Ccube2.quaternion);

      }
      window.addEventListener ("keydown",event=>{
  if(event.keyCode in array)
      array[event.keyCode] = true;
  if(event.keyCode == 32 && sphereBody.position.y<=10)
    sphereBody.velocity.y+=25;
});

window.addEventListener ("keyup",event=>{
  if(event.keyCode in array)
    array[event.keyCode] = false;
});

var gameover = false;
var GameOver = function(x){
  gameover = true;
  if(x==1)
   {
     document.getElementById('refresh').style.display = 'block';
   }
  else if(x==2)
    {
      document.getElementById('win').style.display = 'block';
    }
}
var winner = function(){
  if( player.position.x < 25 && player.position.x > -25 && (player.position.z < 775 && player.position.z > 725))
  {
    return true;
  }
  else {
    return false;
  }
}
var accelerate = function(x){
  if(speed>=maxSpeed || speed<=-maxSpeed){
    return;
  }
  if(x==1)
  {
    speed+=acc;
  }
  else
  {
    speed-=acc;
  }
}
// small letters dont stop
var playerMovement = function(){
  //65 left 68 right 87 up 83 down
  if(array[87]){
        //Forward
        accelerate(1);
    }
  if(array[83]){
        //Back
        accelerate(2);
    }
  if(array[65]){
        //left
        player.rotateY(turnrate);

    }
  if(array[68]){
        //right
        player.rotateY(-turnrate);
    }
  player.translateX(speed);
  controls.target.set(player.position.x,player.position.y,player.position.z);
  controls.update();
}

var decelerate = function(){
  if(speed>0)
    {
      speed-=friction;
    }
    else if(speed<0)
    {
      speed+=friction;
    }
}

  var render = function()
  {
    renderer.render(scene, camera);
  };
  var GameLoop = function()
  {
    // sphereBody.position.x+=0.4;
    if(sphereBody.position.y<0)
    {
      GameOver(1);
    }
    if(winner())
        {
          GameOver(2);
        }
    requestAnimationFrame(GameLoop);
    playerMovement();
    decelerate();
    updatePhysics();
    render();

  }
  initCannon();
  GameLoop();
</script>
  </body>
</html>
