<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <embed id="sound" src="soundtrack\theme.mp3" loop="true" style="display:none;" autostart="true">
    <div class="wrapper">
      <p>Move: W-A-S-D</p>
      <button type="button" id="refresh" onclick="document.location.reload();">Play Again</button>
      <button type="button" id="win" onclick="document.location.reload();">You Win! Play Again</button>
    </div>
    <style>
      body{
        margin: 0px;
        overflow: hidden;
      }
      p{
        position: absolute;
        top: 0%;
        left: 80%;
        z-index: 100;
        display: block;
        color: white;
      }
      #refresh, #win {
          position: absolute;
          top: 50%;
          left: 50%;
          width: 150px;
          height: 150px;
          background-color: darkgreen;
          border-color: darkgreen;
          z-index: 100;
          display: none;
          font-size: 25px;
        }
    </style>

    <script src="lib/three.js"></script>
    <script src="lib/OrbitControls.js"></script>
    <script src="lib/GLTFLoader.js"></script>
    <script>
    (function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()
    var scene = new THREE.Scene();
    //(field of view in degrees, , near clipping plane, far clipping plane)
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera,renderer.domElement);
    controls.maxDistance = 50;
    controls.minDistance = 50;
    controls.maxPolarAngle = Math.PI/3;
    controls.minPolarAngle = Math.PI/3;
    controls.rotateSpeed = 1;
    controls.enabled = false;
    camera.position.y = 50;
    camera.position.x = -40;
    var goal;
    var player;
    const acc=0.1;
    const turnrate=0.05;
    const maxSpeed=2;
    const friction = 0.008;
    var speed = 0;
    //65 left 68 right 87 up 83 down
    var array = {65: false, 68: false, 87: false, 83: false};    //event listener for resizing app to window size
    window.addEventListener('resize', function()
    {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });

    cubeGeometry = new THREE.CubeGeometry(1200, 10, 300);
    cubeMaterial = new THREE.MeshBasicMaterial( {color:'rgb(0,0,250)'} );
    cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
    cube.translateX(450);
    scene.add(cube);

    cube2Geometry = new THREE.CubeGeometry(1200, 10, 300);
    cube2Material = new THREE.MeshBasicMaterial( {color:'rgb(100,10,20)'} );
    cube2 = new THREE.Mesh( cube2Geometry, cube2Material );
    cube2.translateX(450);
    cube2.translateZ(750);
    scene.add(cube2);

    cube6Geometry = new THREE.CubeGeometry(300, 10, 450);
    cube6Material = new THREE.MeshBasicMaterial( {color:'rgb(100,200,210)'} );
    cube6 = new THREE.Mesh( cube6Geometry, cube6Material );
    cube6.translateX(900);
    cube6.translateZ(375);
    scene.add(cube6);


     var ambientLight = new THREE.AmbientLight(0xefebd8, 0.5);
     scene.add(ambientLight);
     var directionalLight = new THREE.DirectionalLight(0xefebd8, 2);
     directionalLight.position.y = 20;
     scene.add(directionalLight);

    loader = new THREE.GLTFLoader();

    // Load a glTF resource
    loader.load(
    	// resource URL
    	'models/moon/scene.gltf',
    	// called when the resource is loaded
      function ( gltf ) {

          player = gltf.scene;
          player.scale.set(0.1,0.1,0.1);
          player.position.y=10;
          controls.target.set(player.position.x,player.position.y,player.position.z);
          controls.update();

          scene.add( player );
      },
    	// called while loading is progressing
    	function ( xhr ) {
    		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
    	},
    	// called when loading has errors
    	function ( error ) {
    		console.log( 'An error happened' );
    	});

    loader.load(
    	// resource URL
    	'models/goal/scene.gltf',
    	// called when the resource is loaded
      function ( gltf ) {
          goal = gltf.scene;
          goal.scale.set(0.5,0.5,0.5);
          goal.position.set(0, 0, 750);
          scene.add( goal );
      },
    	// called while loading is progressing
    	function ( xhr ) {
    		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
    	},
    	// called when loading has errors
    	function ( error ) {
    		console.log( 'An error happened' );
    	});

     {
     loader = new THREE.CubeTextureLoader();
     texture = loader.load([
      'models/skybox/front.png',
      'models/skybox/back.png',
      'models/skybox/up.png',
      'models/skybox/down.png',
      'models/skybox/left.png',
      'models/skybox/right.png',

    ]);
    scene.background = texture;
    }

var render = function()
{
  renderer.render(scene, camera);
};

window.addEventListener ("keydown",event=>{
  if(event.keyCode in array)
      array[event.keyCode] = true;
});

window.addEventListener ("keyup",event=>{
  if(event.keyCode in array)
    array[event.keyCode] = false;
});

var accelerate = function(x){
  if(speed>=maxSpeed || speed<=-maxSpeed){
    return;
  }
  if(x==1)
  {
    speed+=acc;
  }
  else
  {
    speed-=acc;
  }
}
// small letters dont stop
var playerMovement = function(){
  //65 left 68 right 87 up 83 down
  if(array[87]){
        //Forward
        accelerate(1);
    }
  if(array[83]){
        //Back
        accelerate(2);
    }
  if(array[65]){
        //left
        player.rotateY(turnrate);

    }
  if(array[68]){
        //right
        player.rotateY(-turnrate);
    }
  player.translateX(speed);
  controls.target.set(player.position.x,player.position.y,player.position.z);
  controls.update();
}

var decelerate = function(){
  if(speed>0)
    {
      speed-=friction;
    }
    else if(speed<0)
    {
      speed+=friction;
    }
}

var outOfBounds = function(){

  if(player.position.x > 1050 || player.position.x < -150 || player.position.z > 900 || player.position.z < -150  )
  {
    GameOver(1);
  }
  if((player.position.x > -150 && player.position.x < 700 ) && (player.position.z < 600 && player.position.z > 150)){
    GameOver(1);
  }
}

var gameover = false;
var GameOver = function(x){
  gameover = true;
  if(x==1)
   {
     document.getElementById('refresh').style.display = 'block';
   }
  else if(x==2)
    {
      document.getElementById('win').style.display = 'block';
    }
}
var winner = function(){
  if( player.position.x < 25 && player.position.x > -25 && (player.position.z < 775 && player.position.z > 725))
  {
    return true;
  }
  else {
    return false;
  }
}
var GameLoop = function()
{

  if(player&&goal&&!gameover)
    {
      playerMovement();
      outOfBounds();
      decelerate();
      if(winner())
        {
          GameOver(2);
        }
    }


  requestAnimationFrame(GameLoop);

  render();
}
  GameLoop();
    </script>
  </body>
</html>
